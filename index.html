<!DOCTYPE html>

<html>

  <head>
    <img src="WebBanner2023.png" alt="Banner" width="1200" height="300">
      <h1><b>ENG0018 Computer Laboratory 2025/26</b><h1>
      <h2>Student URN: 817287 </h2>
    <hr>
    <h2 style=”font-family:calibri:”><b>Vibe Coding: A coding revolution or idle programming?  </b></h2>
    </hr>

     <!style for tables>   
        <style>
          table {
            font-family: arial, courier-new
            border-collapse: collapse;
            width: 30%;

          }

         td, th {
           border: 1px  solid #dddddd;
           text-align: left; 
           padding: 8px; 

          }
            
          tr:nth-child(even) {
            background-color: #dddddd;
          }

        </style>
    <style>
  p.ex1 {
    margin-left: 100px;
    white-space: normal;
  }  
  </style>
</head>

<meta name="viewport" content="width=device-width, initial-scale=1">   
<link rel="stylesheet" href="https://www.w3schools.com/w3css/4/w3.css">        
<style>
.mySlides{display:none;}
</style>

<body style="background-color:#FFFFFF;margin-left:50px;">
<!table of contents>
<table>

 <tr>
   <th><h3>Table of contents</h3></th>
 </tr>
 <tr> 
   <td><a href="#Abstract">Abstract</td>
 </tr>
 <tr> 
   <td><a href="#Introduction">Introduction</td>
 </tr>
 <tr>
   <td><a href="#Analysis and discussion">Analysis and discussion</td>
 </tr> 
 <tr> 
   <td><a href="#References">References</td>
 </tr> 
</table>
<hr>

<h3 id="Abstract">Abstract</h3>
<p class="ex1"> 
Karpathy, A introduced the term vibe coding in 2025, describing a transformative software development paradigm in which developers articulate high-level intentions through natural language while AI systems generate executable code. </p>
<p>This transformation redefines programmers as conceptual directors who guide generative AI to produce code rather than manually writing syntax. Advocates highlight significant gains in productivity, creativity, and accessibility, enabling non-technical users to prototype software rapidly. </p>
<p>However, this shift raises concerns about declining code comprehension, rapid technical debt accumulation, and vulnerabilities introduced by unreviewed AI-generated code. Ethical and legal questions regarding responsibility, authorship, accountability, and system integrity further complicate adoption. </p>
<p>Vibe coding is mainly effective in experimenting or the early stages of development. Its success depends on maintaining critical oversight and reliable human–AI collaboration in software creation. </p>

  
<h3 id="Introduction">Introduction</h3>
<p id="Introduction_InText">
The term “vibe coding” was first coined by the well-respected AI researcher and Computer Scientist Andrej Karpathy in February 2025. He defines it as a new software development paradigm where developers use AI tools and communicate through natural human languages to state their high-level intent rather than writing the computer code (Kitishian, 2025). 
This marks a revolutionary shift in software development. Rather than using logic and algorithmic thinking, software developers become “conceptual directors”. This means developers become guides articulating program intent, while AI implements it. The key is no longer programming in specific languages but the ability to articulate the required outcome by following the “vibe” and evaluating AI-generated code (Horvat, 2025). Vibe coding provoked significant debate amongst computer scientists. Proponents describe it as a major advancement and an accessible way for software creation, while critics warn that it is “idle programming” (Smith, 2025) (Szymanski, 2025).</p>


<h3 id="Analysis and discussion">Analysis and discussion</h3>
<p id="Analysis_InText"> 
A 2025 study on ResearchGate formalised vibe coding as a “software development paradigm in which developers express their intentions about the software product using natural language”, created through a generative model, and formed into executable code (Horvat, 2025). Meske, C. et al. described context as “reconfiguration of intent mediation in software development,” comparing it to earlier developments in coding that advanced programming from machine code (0s and 1s) to human-readable syntax such as MATLAB (Meske et al., 2025).
Practically, vibe coding is unfolded by iterative prompting, code execution (running code), and logical refinement. Developers issue feedback on AI-generated code. Examples are “optimise database queries” or “add user authentication,” with AI modifying the existing code autonomously. The emphasis moves from writing code to collaborating with AI through dialogue (Horvat, 2025). Following workflow is used: </p>
<pre>
<img src="VibeCoding.JPG" alt="" width="500" height="333">
</pre>
<p> (Sapkota, 2025)</p>

  
<h4>The Changing Role of the Programmer</h4>
<p id="Role_InText">
Ad hoc software development, logic and manual control are key skills for developers. Vibe coding changes required developer skills, who move from creating code to curating (Pajo, 2025). In their article, Moore & Tatonetti noted that the focus shifts from human syntax mastery to human–AI interaction. (Moore & Tatonetti, 2025) This transition reduces the need for technical knowledge. In addition, non-technical people can now prototype applications through conversational interfaces with AI (Pajo, 2025). Consequently, vibe coding makes programming more accessible to people, allowing previously excluded non-technical people to take part in software creation.
However, this abstraction comes with risk. When developers are unaware of how their code operates, debugging and long-term maintenance become increasingly difficult (Horvat, 2025). This gets worse for non-technical people who have no expertise in programming.</p>

  
<h4>Advantages</h4>
Vibe coding has a revolutionary potential for major advantages in productivity, creativity, and accessibility. Developers report productivity increases by 10 times for prototypes and experimental applications. Karpathy (Kitishian, 2025) suggested reasoning as AI allows humans to “care about the bigger picture” rather than manual syntax.
Klover.ai report (Kitishian, 2025) outlines other benefits: faster experimentation, reduced boilerplate [8], and better integration between design intent and software output. This compares to historical technological shifts, such as the introduction of graphical user interfaces, replacing command-line interaction.
Vibe coding aligns with the ongoing movement toward natural-language programming, coding using human languages. Making programming more accessible to non-experts (Pajo, 2025). Offering a significant reduction in development time and conceptual overhead.

  
<h4>Criticisms and Risks</h4>
Despite appeals, vibe coding raises serious concerns. The biggest criticism is that developers are losing code comprehension. As developers increasingly rely on AI-generated code, over time, they might lose the ability to understand and validate software systems (Horvat, 2025). Pajo warns that this would undermine accountability and system integrity. (Pajo, 2025)
Szymanski states that vibe-coded projects accumulate technical debt rapidly, as generated code often gets undocumented, and is often generated as a single block of code, which is not very efficient (Szymanski, 2025). AI-generated repositories frequently include hard-coded secrets, insecure dependencies, and inefficient architectures. Without expertise review, these vulnerabilities can propagate unchecked and cause breakdowns and errors (Moore & Tatonetti, 2025) (Sabra et al., 2025).
Ethical considerations such as determining the responsibility in case AI-generated system failure. Who will be responsible, the developer, organisation/company, or AI systems? Vibe coding “reconfigures the moral and professional boundaries of authorship in software systems,” requiring new laws and ethical considerations (Meske et al., 2025).

  
<h4>Appropriate Use</h4>
Vibe coding is context-dependent and proficient in speed and experimentation, making it useful in academic research and for startup projects. Unsuitable for mission-critical and for regulation-requiring tasks, such as healthcare and finance (Horvat, 2025) (Szymanski, 2025).
For using vibe coding, a hybrid workflow is proposed, which combines AI-generated code acting as scaffolding, alongside human-created architecture (Pajo, 2025). This model retains the advantages of AI automation while reducing potential risks through validation and human oversight. As Karpathy states, “It’s not that we stop caring about code—it’s that we let AI handle the boilerplate so humans can care about the bigger picture” (Kitishian, 2025). 

  
<h4>Cultural and Legal Implications</h4>
Vibe coding is more than an innovation; it represents a cultural and philosophical shift in software principles. It reframes programming as an act of expression rather than construction. As Meske et al. note, it moves programming closer to conversation than computation (Meske et al., 2025).
However, this shift causes intellectual work in software development to disappear. Karpathy (Kitishian, 2025) refers to vibe coding as a disengaged practice where developers do not even know there is code. The biggest challenge is in maintaining a high-level critical understanding within this new workflow.
Vibe coding’s future lies in AI literacy, AI’s capacity to guide, and inspect. This distinguishes effective collaboration from automation.
  
<h4>Conclusion</h4>
Empowerment and dependency are combined by vibe coding. While revolutionising speed and accessibility, it threatens developers’ code comprehension and accountability. As AI tools develop, the challenge for developers and educators will balance efficiency with understanding.
Whether it becomes a new coding standard or a trend of “idle programming”, it will depend on human discipline and critical oversight. When used responsibly, vibe coding may indeed represent the next step in human–machine collaboration, where software creation is not written but spoken.
</p>

  
<h3 id="References">References</h3>
<p>[1] Kitishian, D. (2025) Andrej Karpathy Vibe coding - klover.ai, Andrej Karpathy Vibe Coding. Available at: <a href=”https://www.klover.ai/andrej-karpathy-vibe-coding/”>https://www.klover.ai/andrej-karpathy-vibe-coding/</a> (Accessed: 02 December 2025). </p>
<p>[2] Horvat, M. (2025) What is Vibe Coding and When Should You Use It or Not, ResearchGate Publications. Available at:  <a href=”https://www.klover.ai/andrej-karpathy-vibe-coding/”>https://www.klover.ai/andrej-karpathy-vibe-coding/</a> (Accessed: 27 October 2025). </p>
<p>[3] Smith, M. (2025) Engineers are using AI to code based on Vibes, Engineers Are Using AI to Code Based on Vibes. Available at: <a href=”https://spectrum.ieee.org/vibe-coding"/>https://spectrum.ieee.org/vibe-coding</a> (Accessed: 27 November 2025). </p>
<p>[4] Szymanski, P.F. (2025) The pros and cons of vibe coding, The Rise (and Risk) of Vibe Coding. Available at: <a href=”https://softwaremind.com/blog/the-rise-and-risk-of-vibe-coding-whats-worth-knowing"/>https://softwaremind.com/blog/the-rise-and-risk-of-vibe-coding-whats-worth-knowing </a> (Accessed: 26 November 2025). </p>
<p>[5] Meske, C. et al. (2025) Vibe Coding as a reconfiguration of intent mediation in software development: Definition, implications, and research agenda, arXiv.org. Available at: <a href=”https://arxiv.org/abs/2507.21928"/>https://arxiv.org/abs/2507.21928 </a> (Accessed: 02 December 2025). </p>
<p>[6] Pajo, P. (2025) (PDF) vibe coding: Revolutionizing software development with AI-Generated Code, Vibe Coding: Revolutionizing Software Development with AI-Generated Code. Available at: <a href=”https://www.researchgate.net/publication/389848540_Vibe_Coding_Revolutionizing_Software_Development_with_AI-Generated_Code"/>https://www.researchgate.net/publication/389848540_Vibe_Coding_Revolutionizing_Software_Development_with_AI-Generated_Code </a> (Accessed: 19 November 2025). </p>
<p>[7] Moore, J.H. and Tatonetti, N. (2025) Vibe coding: A new paradigm for biomedical software development - biodata mining, Vibe coding: a new paradigm for biomedical software development. Available at: <a href=”https://link.springer.com/article/10.1186/s13040-025-00462-9"/>https://link.springer.com/article/10.1186/s13040-025-00462-9 </a> (Accessed: 01 December 2025). </p>
<p>[8] What is boilerplate code? (no date) What is Boilerplate Code? Available at: <a href=”https://aws.amazon.com/what-is/boilerplate-code/" />https://aws.amazon.com/what-is/boilerplate-code/ </a> (Accessed: 01 December 2025). </p>
<p>[9] Sabra, A., Schmitt, O. and Tyler, J. (2025) Assessing the quality and security of AI-generated code: A quantitative analysis, Assessing the Quality and Security of AI-Generated Code: A Quantitative Analysis. Available at: <a href=”https://arxiv.org/abs/2508.14727" />https://arxiv.org/abs/2508.14727 </a> (Accessed: 01 December 2025). </p>






<!-- //////////////////////////////////////////////////////////////////////////////// -->
  <!-- ////////////////////////////// Adding last update ////////////////////////////// -->
  <!-- //////////////////////////////////////////////////////////////////////////////// -->
    <!-- Last commit time display -->
<div id="last-updated">Loading last update time...</div>
<!-- Verify Button -->
<button onclick="verifyLastUpdatedTime()" style="display: block; margin: 10px auto; padding: 8px 16px;">
    Verify Last Modified Time
</button>
<script>
    async function getLastUpdatedTime() {
        const username = 'Baris448';
        const repo = '6913233';
       
        const url = `https://api.github.com/repos/${username}/${repo}/commits`;
        try {
            const response = await fetch(url, {
                method: 'GET',
                headers: {
                    'Accept': 'application/vnd.github.v3+json',
                }
            });
            if (!response.ok) {
                throw new Error(`Error fetching data: ${response.status} - ${response.statusText}`);
            }
            const commits = await response.json();
            if (commits && commits.length > 0) {
                const lastCommitDate = new Date(commits[0].commit.committer.date);
               
                // Displaying the time on load
                document.getElementById('last-updated').innerText = `Last Modified Time: ${lastCommitDate.toLocaleString()}`;
            } else {
                document.getElementById('last-updated').innerText = 'No commits found in the repository.';
            }
        } catch (error) {
            console.error('Error fetching the last updated time:', error);
            document.getElementById('last-updated').innerText = 'Error fetching update time. Please check the repository details.';
        }
    }
    // Function to verify the last update time by re-fetching it from the API
    async function verifyLastUpdatedTime() {
        document.getElementById('last-updated').innerText = 'Verifying...';
        await getLastUpdatedTime();
        alert("Last modified time has been successfully verified from GitHub API.");
    }
    // Initial load to display the time on page load
    window.onload = getLastUpdatedTime;
</script>


  <!-- //////////////////////////////////////////////////////////////////////////////// -->
  <!-- ////////////////////////////// Word count function ////////////////////////////// -->
  <!-- //////////////////////////////////////////////////////////////////////////////// -->
<!-- Placeholder for total word count -->
<p id="totalWordCount"></p>
<hr>
<script>
  // Function to calculate and display word count for a specified section
  function displayWordCount(sectionId, outputId) {
    // Get the text content from the specified section
    const text = document.getElementById(sectionId).textContent;
    // Split text into words based on spaces and filter out any empty strings
    const wordArray = text.trim().split(/\s+/);
    // Count the words
    const wordCount = wordArray.length;
    // Return the word count for summing purposes
    return wordCount;
  }
  // Function to calculate and display total word count from selected sections
  function displayTotalWordCount() {
    // Calculate word count for each section and accumulate the total
    const IntroductionCount = displayWordCount("Introduction_InText");
    const AnalysisCount = displayWordCount("Analysis_InText");
    const RoleCount = displayWordCount("Role_InText");
    // Calculate the sum of all selected sections
    const totalWordCount = IntroductionCount + AnalysisCount + RoleCount;
    // Display the total word count
    document.getElementById("totalWordCount").innerText = `Total word count: ${totalWordCount}`;
  }
  // Run the function for specific sections and display total count when the page loads
  window.onload = displayTotalWordCount;
</script>
</body>
</html>


  


